// Code generated by protoc-gen-go. DO NOT EDIT.
// source: tokens/replicator/replicator.proto

package replicator

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type TokenOffersFilter struct {
	IssuerId             string      `protobuf:"bytes,1,opt,name=issuer_id,json=issuerId,proto3" json:"issuer_id,omitempty"`
	Params               *Pagination `protobuf:"bytes,2,opt,name=params,proto3" json:"params,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TokenOffersFilter) Reset()         { *m = TokenOffersFilter{} }
func (m *TokenOffersFilter) String() string { return proto.CompactTextString(m) }
func (*TokenOffersFilter) ProtoMessage()    {}
func (*TokenOffersFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1dab6cdd6b3b29, []int{0}
}

func (m *TokenOffersFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TokenOffersFilter.Unmarshal(m, b)
}
func (m *TokenOffersFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TokenOffersFilter.Marshal(b, m, deterministic)
}
func (m *TokenOffersFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenOffersFilter.Merge(m, src)
}
func (m *TokenOffersFilter) XXX_Size() int {
	return xxx_messageInfo_TokenOffersFilter.Size(m)
}
func (m *TokenOffersFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenOffersFilter.DiscardUnknown(m)
}

var xxx_messageInfo_TokenOffersFilter proto.InternalMessageInfo

func (m *TokenOffersFilter) GetIssuerId() string {
	if m != nil {
		return m.IssuerId
	}
	return ""
}

func (m *TokenOffersFilter) GetParams() *Pagination {
	if m != nil {
		return m.Params
	}
	return nil
}

type TokenOffers struct {
	Offers               []*TokenOffer `protobuf:"bytes,1,rep,name=offers,proto3" json:"offers,omitempty"`
	Total                uint64        `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TokenOffers) Reset()         { *m = TokenOffers{} }
func (m *TokenOffers) String() string { return proto.CompactTextString(m) }
func (*TokenOffers) ProtoMessage()    {}
func (*TokenOffers) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1dab6cdd6b3b29, []int{1}
}

func (m *TokenOffers) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TokenOffers.Unmarshal(m, b)
}
func (m *TokenOffers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TokenOffers.Marshal(b, m, deterministic)
}
func (m *TokenOffers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenOffers.Merge(m, src)
}
func (m *TokenOffers) XXX_Size() int {
	return xxx_messageInfo_TokenOffers.Size(m)
}
func (m *TokenOffers) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenOffers.DiscardUnknown(m)
}

var xxx_messageInfo_TokenOffers proto.InternalMessageInfo

func (m *TokenOffers) GetOffers() []*TokenOffer {
	if m != nil {
		return m.Offers
	}
	return nil
}

func (m *TokenOffers) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

type TokenOffer struct {
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// TODO: discuss
	//  ? Should we assume decimal prices
	//  ? Add units field
	Price      uint64      `protobuf:"varint,2,opt,name=price,proto3" json:"price,omitempty"`
	IssuerInfo *IssuerInfo `protobuf:"bytes,3,opt,name=issuer_info,json=issuerInfo,proto3" json:"issuer_info,omitempty"`
	// TODO: as soon as authentication of TokenWallet holder at Replicator would be implemented,
	// this value should be revisioned
	BuyerId string `protobuf:"bytes,4,opt,name=buyer_id,json=buyerId,proto3" json:"buyer_id,omitempty"`
	// This field protects issuers from such a case, when potential buyer successfully acquires dozens
	// of signatures just in case if that issuer would raise up the price later. If a Token Wallet
	// holder would like to open channel with an outdated offer, Replicator would reject to register
	// this purchase and buyer stays unprotected
	ValidUntilMillis     int64    `protobuf:"varint,5,opt,name=valid_until_millis,json=validUntilMillis,proto3" json:"valid_until_millis,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TokenOffer) Reset()         { *m = TokenOffer{} }
func (m *TokenOffer) String() string { return proto.CompactTextString(m) }
func (*TokenOffer) ProtoMessage()    {}
func (*TokenOffer) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1dab6cdd6b3b29, []int{2}
}

func (m *TokenOffer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TokenOffer.Unmarshal(m, b)
}
func (m *TokenOffer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TokenOffer.Marshal(b, m, deterministic)
}
func (m *TokenOffer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenOffer.Merge(m, src)
}
func (m *TokenOffer) XXX_Size() int {
	return xxx_messageInfo_TokenOffer.Size(m)
}
func (m *TokenOffer) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenOffer.DiscardUnknown(m)
}

var xxx_messageInfo_TokenOffer proto.InternalMessageInfo

func (m *TokenOffer) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *TokenOffer) GetPrice() uint64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *TokenOffer) GetIssuerInfo() *IssuerInfo {
	if m != nil {
		return m.IssuerInfo
	}
	return nil
}

func (m *TokenOffer) GetBuyerId() string {
	if m != nil {
		return m.BuyerId
	}
	return ""
}

func (m *TokenOffer) GetValidUntilMillis() int64 {
	if m != nil {
		return m.ValidUntilMillis
	}
	return 0
}

type IssuerInfo struct {
	// This value is explicetely used by Replicator to uniquely identify related issuer later in order to ban him
	// (discredite case), since "identity_pubkey", "host" may be changed
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The following field values are used to open payment channel, invoices commands execution etc.
	IdentityPubkey       string   `protobuf:"bytes,2,opt,name=identity_pubkey,json=identityPubkey,proto3" json:"identity_pubkey,omitempty"`
	Host                 string   `protobuf:"bytes,3,opt,name=host,proto3" json:"host,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IssuerInfo) Reset()         { *m = IssuerInfo{} }
func (m *IssuerInfo) String() string { return proto.CompactTextString(m) }
func (*IssuerInfo) ProtoMessage()    {}
func (*IssuerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1dab6cdd6b3b29, []int{3}
}

func (m *IssuerInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IssuerInfo.Unmarshal(m, b)
}
func (m *IssuerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IssuerInfo.Marshal(b, m, deterministic)
}
func (m *IssuerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IssuerInfo.Merge(m, src)
}
func (m *IssuerInfo) XXX_Size() int {
	return xxx_messageInfo_IssuerInfo.Size(m)
}
func (m *IssuerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IssuerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IssuerInfo proto.InternalMessageInfo

func (m *IssuerInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *IssuerInfo) GetIdentityPubkey() string {
	if m != nil {
		return m.IdentityPubkey
	}
	return ""
}

func (m *IssuerInfo) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

type TokenPurchase struct {
	Offer *TokenOffer `protobuf:"bytes,1,opt,name=offer,proto3" json:"offer,omitempty"`
	// Presents signature of offer. This signature is used to identify,
	// that issuer accepts terms described in the offer and is responsible
	// to follow them in this transaction. If signature is not valid, then
	// channel should be closed. Otherwise, Replicator registers token
	// purchase details provided and tracks blockchain for a closing transaction
	// in order to determine if the issuer were not break terms
	IssuerSignature      string   `protobuf:"bytes,2,opt,name=issuer_signature,json=issuerSignature,proto3" json:"issuer_signature,omitempty"`
	InitialTxHash        string   `protobuf:"bytes,3,opt,name=initial_tx_hash,json=initialTxHash,proto3" json:"initial_tx_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TokenPurchase) Reset()         { *m = TokenPurchase{} }
func (m *TokenPurchase) String() string { return proto.CompactTextString(m) }
func (*TokenPurchase) ProtoMessage()    {}
func (*TokenPurchase) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1dab6cdd6b3b29, []int{4}
}

func (m *TokenPurchase) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TokenPurchase.Unmarshal(m, b)
}
func (m *TokenPurchase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TokenPurchase.Marshal(b, m, deterministic)
}
func (m *TokenPurchase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenPurchase.Merge(m, src)
}
func (m *TokenPurchase) XXX_Size() int {
	return xxx_messageInfo_TokenPurchase.Size(m)
}
func (m *TokenPurchase) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenPurchase.DiscardUnknown(m)
}

var xxx_messageInfo_TokenPurchase proto.InternalMessageInfo

func (m *TokenPurchase) GetOffer() *TokenOffer {
	if m != nil {
		return m.Offer
	}
	return nil
}

func (m *TokenPurchase) GetIssuerSignature() string {
	if m != nil {
		return m.IssuerSignature
	}
	return ""
}

func (m *TokenPurchase) GetInitialTxHash() string {
	if m != nil {
		return m.InitialTxHash
	}
	return ""
}

type CommonResult struct {
	Succeded             bool     `protobuf:"varint,1,opt,name=succeded,proto3" json:"succeded,omitempty"`
	ErrorDescription     string   `protobuf:"bytes,2,opt,name=error_description,json=errorDescription,proto3" json:"error_description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommonResult) Reset()         { *m = CommonResult{} }
func (m *CommonResult) String() string { return proto.CompactTextString(m) }
func (*CommonResult) ProtoMessage()    {}
func (*CommonResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1dab6cdd6b3b29, []int{5}
}

func (m *CommonResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommonResult.Unmarshal(m, b)
}
func (m *CommonResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommonResult.Marshal(b, m, deterministic)
}
func (m *CommonResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonResult.Merge(m, src)
}
func (m *CommonResult) XXX_Size() int {
	return xxx_messageInfo_CommonResult.Size(m)
}
func (m *CommonResult) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonResult.DiscardUnknown(m)
}

var xxx_messageInfo_CommonResult proto.InternalMessageInfo

func (m *CommonResult) GetSucceded() bool {
	if m != nil {
		return m.Succeded
	}
	return false
}

func (m *CommonResult) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

type TokenBalancesFilter struct {
	Params               *Pagination `protobuf:"bytes,1,opt,name=params,proto3" json:"params,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TokenBalancesFilter) Reset()         { *m = TokenBalancesFilter{} }
func (m *TokenBalancesFilter) String() string { return proto.CompactTextString(m) }
func (*TokenBalancesFilter) ProtoMessage()    {}
func (*TokenBalancesFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1dab6cdd6b3b29, []int{6}
}

func (m *TokenBalancesFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TokenBalancesFilter.Unmarshal(m, b)
}
func (m *TokenBalancesFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TokenBalancesFilter.Marshal(b, m, deterministic)
}
func (m *TokenBalancesFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenBalancesFilter.Merge(m, src)
}
func (m *TokenBalancesFilter) XXX_Size() int {
	return xxx_messageInfo_TokenBalancesFilter.Size(m)
}
func (m *TokenBalancesFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenBalancesFilter.DiscardUnknown(m)
}

var xxx_messageInfo_TokenBalancesFilter proto.InternalMessageInfo

func (m *TokenBalancesFilter) GetParams() *Pagination {
	if m != nil {
		return m.Params
	}
	return nil
}

type TokenBalances struct {
	Balances             []*TokenBalance `protobuf:"bytes,1,rep,name=balances,proto3" json:"balances,omitempty"`
	Total                uint64          `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *TokenBalances) Reset()         { *m = TokenBalances{} }
func (m *TokenBalances) String() string { return proto.CompactTextString(m) }
func (*TokenBalances) ProtoMessage()    {}
func (*TokenBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1dab6cdd6b3b29, []int{7}
}

func (m *TokenBalances) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TokenBalances.Unmarshal(m, b)
}
func (m *TokenBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TokenBalances.Marshal(b, m, deterministic)
}
func (m *TokenBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenBalances.Merge(m, src)
}
func (m *TokenBalances) XXX_Size() int {
	return xxx_messageInfo_TokenBalances.Size(m)
}
func (m *TokenBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenBalances.DiscardUnknown(m)
}

var xxx_messageInfo_TokenBalances proto.InternalMessageInfo

func (m *TokenBalances) GetBalances() []*TokenBalance {
	if m != nil {
		return m.Balances
	}
	return nil
}

func (m *TokenBalances) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

type TokenBalance struct {
	Token                string   `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	Available            uint64   `protobuf:"varint,2,opt,name=available,proto3" json:"available,omitempty"`
	Frozen               uint64   `protobuf:"varint,3,opt,name=frozen,proto3" json:"frozen,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TokenBalance) Reset()         { *m = TokenBalance{} }
func (m *TokenBalance) String() string { return proto.CompactTextString(m) }
func (*TokenBalance) ProtoMessage()    {}
func (*TokenBalance) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1dab6cdd6b3b29, []int{8}
}

func (m *TokenBalance) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TokenBalance.Unmarshal(m, b)
}
func (m *TokenBalance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TokenBalance.Marshal(b, m, deterministic)
}
func (m *TokenBalance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenBalance.Merge(m, src)
}
func (m *TokenBalance) XXX_Size() int {
	return xxx_messageInfo_TokenBalance.Size(m)
}
func (m *TokenBalance) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenBalance.DiscardUnknown(m)
}

var xxx_messageInfo_TokenBalance proto.InternalMessageInfo

func (m *TokenBalance) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *TokenBalance) GetAvailable() uint64 {
	if m != nil {
		return m.Available
	}
	return 0
}

func (m *TokenBalance) GetFrozen() uint64 {
	if m != nil {
		return m.Frozen
	}
	return 0
}

type Pagination struct {
	Limit                uint64   `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset               uint64   `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Pagination) Reset()         { *m = Pagination{} }
func (m *Pagination) String() string { return proto.CompactTextString(m) }
func (*Pagination) ProtoMessage()    {}
func (*Pagination) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce1dab6cdd6b3b29, []int{9}
}

func (m *Pagination) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Pagination.Unmarshal(m, b)
}
func (m *Pagination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Pagination.Marshal(b, m, deterministic)
}
func (m *Pagination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pagination.Merge(m, src)
}
func (m *Pagination) XXX_Size() int {
	return xxx_messageInfo_Pagination.Size(m)
}
func (m *Pagination) XXX_DiscardUnknown() {
	xxx_messageInfo_Pagination.DiscardUnknown(m)
}

var xxx_messageInfo_Pagination proto.InternalMessageInfo

func (m *Pagination) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *Pagination) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func init() {
	proto.RegisterType((*TokenOffersFilter)(nil), "lnrpc.TokenOffersFilter")
	proto.RegisterType((*TokenOffers)(nil), "lnrpc.TokenOffers")
	proto.RegisterType((*TokenOffer)(nil), "lnrpc.TokenOffer")
	proto.RegisterType((*IssuerInfo)(nil), "lnrpc.IssuerInfo")
	proto.RegisterType((*TokenPurchase)(nil), "lnrpc.TokenPurchase")
	proto.RegisterType((*CommonResult)(nil), "lnrpc.CommonResult")
	proto.RegisterType((*TokenBalancesFilter)(nil), "lnrpc.TokenBalancesFilter")
	proto.RegisterType((*TokenBalances)(nil), "lnrpc.TokenBalances")
	proto.RegisterType((*TokenBalance)(nil), "lnrpc.TokenBalance")
	proto.RegisterType((*Pagination)(nil), "lnrpc.Pagination")
}

func init() {
	proto.RegisterFile("tokens/replicator/replicator.proto", fileDescriptor_ce1dab6cdd6b3b29)
}

var fileDescriptor_ce1dab6cdd6b3b29 = []byte{
	// 649 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xdd, 0x6e, 0xd3, 0x30,
	0x14, 0x56, 0xba, 0x76, 0xb4, 0x67, 0x7f, 0x9d, 0x37, 0x50, 0x29, 0x5c, 0x54, 0xb9, 0x60, 0x9b,
	0x80, 0x56, 0x1a, 0x88, 0x0b, 0x2e, 0xd0, 0x34, 0x26, 0x60, 0x17, 0xc0, 0x64, 0xc6, 0x10, 0xe3,
	0x22, 0x72, 0x13, 0xa7, 0xb1, 0xea, 0xda, 0x91, 0xed, 0x4c, 0x2b, 0xaf, 0xc0, 0x0b, 0xf0, 0x22,
	0xbc, 0x1f, 0x8a, 0xe3, 0x34, 0x99, 0xd6, 0x09, 0x89, 0x8b, 0x48, 0xe7, 0x7c, 0xe7, 0xf3, 0x39,
	0x3e, 0x5f, 0xbe, 0x04, 0x7c, 0x23, 0xa7, 0x54, 0xe8, 0x91, 0xa2, 0x29, 0x67, 0x21, 0x31, 0x52,
	0xd5, 0xc2, 0x61, 0xaa, 0xa4, 0x91, 0xa8, 0xc5, 0x85, 0x4a, 0x43, 0xff, 0x07, 0x6c, 0x9f, 0xe7,
	0xe4, 0xcf, 0x71, 0x4c, 0x95, 0x7e, 0xc7, 0xb8, 0xa1, 0x0a, 0x3d, 0x82, 0x0e, 0xd3, 0x3a, 0xa3,
	0x2a, 0x60, 0x51, 0xcf, 0x1b, 0x78, 0xfb, 0x1d, 0xdc, 0x2e, 0x80, 0xd3, 0x08, 0x1d, 0xc0, 0x6a,
	0x4a, 0x14, 0x99, 0xe9, 0x5e, 0x63, 0xe0, 0xed, 0xaf, 0x1d, 0x6e, 0x0f, 0x6d, 0xa7, 0xe1, 0x19,
	0x99, 0x30, 0x41, 0x0c, 0x93, 0x02, 0x3b, 0x82, 0xff, 0x09, 0xd6, 0x6a, 0xcd, 0xf3, 0x93, 0xd2,
	0x46, 0x3d, 0x6f, 0xb0, 0x52, 0x3b, 0x59, 0x71, 0xb0, 0x23, 0xa0, 0x5d, 0x68, 0x19, 0x69, 0x08,
	0xb7, 0x33, 0x9a, 0xb8, 0x48, 0xfc, 0x3f, 0x1e, 0x40, 0x45, 0x2e, 0x48, 0x53, 0x2a, 0xdc, 0x15,
	0x8b, 0x24, 0x47, 0x53, 0xc5, 0x42, 0x5a, 0x1e, 0xb5, 0x09, 0x3a, 0x84, 0xb5, 0x72, 0x25, 0x11,
	0xcb, 0xde, 0xca, 0x8d, 0xab, 0x9f, 0x16, 0xbb, 0x89, 0x58, 0x62, 0x60, 0x8b, 0x18, 0x3d, 0x84,
	0xf6, 0x38, 0x9b, 0x17, 0x2a, 0x34, 0xed, 0x88, 0x7b, 0x36, 0x3f, 0x8d, 0xd0, 0x33, 0x40, 0x57,
	0x84, 0xb3, 0x28, 0xc8, 0x84, 0x61, 0x3c, 0x98, 0x31, 0xce, 0x99, 0xee, 0xb5, 0x06, 0xde, 0xfe,
	0x0a, 0xee, 0xda, 0xca, 0xd7, 0xbc, 0xf0, 0xd1, 0xe2, 0xfe, 0x77, 0x80, 0x6a, 0x04, 0xda, 0x84,
	0xc6, 0x42, 0xd6, 0x06, 0x8b, 0xd0, 0x1e, 0x6c, 0xb1, 0x88, 0x0a, 0xc3, 0xcc, 0x3c, 0x48, 0xb3,
	0xf1, 0x94, 0xce, 0xed, 0xd5, 0x3b, 0x78, 0xb3, 0x84, 0xcf, 0x2c, 0x8a, 0x10, 0x34, 0x13, 0xa9,
	0x8d, 0xbd, 0x7c, 0x07, 0xdb, 0xd8, 0xff, 0xe5, 0xc1, 0x86, 0x95, 0xe4, 0x2c, 0x53, 0x61, 0x42,
	0x34, 0x45, 0x7b, 0xd0, 0xb2, 0x22, 0xda, 0x09, 0x4b, 0x45, 0x2e, 0xea, 0xe8, 0x00, 0xba, 0x4e,
	0x12, 0xcd, 0x26, 0x82, 0x98, 0x4c, 0x51, 0x37, 0x78, 0xab, 0xc0, 0xbf, 0x94, 0x30, 0x7a, 0x02,
	0x5b, 0x4c, 0x30, 0xc3, 0x08, 0x0f, 0xcc, 0x75, 0x90, 0x10, 0x9d, 0xb8, 0x4b, 0x6c, 0x38, 0xf8,
	0xfc, 0xfa, 0x03, 0xd1, 0x89, 0xff, 0x0d, 0xd6, 0xdf, 0xca, 0xd9, 0x4c, 0x0a, 0x4c, 0x75, 0xc6,
	0x0d, 0xea, 0x43, 0x5b, 0x67, 0x61, 0x48, 0x23, 0x5a, 0x2c, 0xdc, 0xc6, 0x8b, 0x1c, 0x3d, 0x85,
	0x6d, 0xaa, 0x94, 0x54, 0x41, 0x44, 0x75, 0xa8, 0x58, 0x9a, 0x3b, 0xc7, 0xcd, 0xef, 0xda, 0xc2,
	0x49, 0x85, 0xfb, 0x47, 0xb0, 0x63, 0x17, 0x38, 0x26, 0x9c, 0x88, 0x90, 0x96, 0x46, 0xad, 0xbc,
	0xe8, 0xfd, 0xcb, 0x8b, 0x17, 0x4e, 0xa7, 0xb2, 0x03, 0x1a, 0x41, 0x7b, 0xec, 0x62, 0xe7, 0xc7,
	0x9d, 0xba, 0x54, 0x8e, 0x87, 0x17, 0xa4, 0x3b, 0x3c, 0x79, 0x09, 0xeb, 0x75, 0xfe, 0x1d, 0xa6,
	0x7c, 0x0c, 0x1d, 0x72, 0x45, 0x18, 0x27, 0x63, 0x5e, 0x1a, 0xb3, 0x02, 0xd0, 0x03, 0x58, 0x8d,
	0x95, 0xfc, 0x49, 0x85, 0x55, 0xb5, 0x89, 0x5d, 0xe6, 0xbf, 0x06, 0xa8, 0x36, 0xc9, 0x3b, 0x73,
	0x36, 0x63, 0xc6, 0x76, 0x6e, 0xe2, 0x22, 0xc9, 0xcf, 0xca, 0x38, 0xd6, 0xd4, 0xb8, 0xb6, 0x2e,
	0x3b, 0xfc, 0xdd, 0x00, 0xc0, 0x8b, 0x8f, 0x1e, 0xbd, 0x81, 0xcd, 0xf7, 0xd4, 0xd4, 0xbf, 0xc6,
	0xde, 0x2d, 0x63, 0x38, 0x55, 0xfb, 0xe8, 0x76, 0x05, 0x1d, 0xc1, 0xce, 0x05, 0x55, 0x2c, 0x9e,
	0xdf, 0x34, 0xdb, 0x6e, 0x9d, 0x5a, 0xa2, 0xfd, 0x52, 0xc8, 0x1b, 0x5e, 0x38, 0x86, 0xfb, 0x98,
	0x4e, 0x98, 0x36, 0x54, 0xfd, 0x77, 0x8f, 0x13, 0xe8, 0x96, 0x5b, 0x2c, 0xde, 0x63, 0x7f, 0xc9,
	0x5b, 0x2b, 0x37, 0xd9, 0x5d, 0x56, 0x3b, 0x7e, 0x75, 0xf9, 0x72, 0xc2, 0x4c, 0x92, 0x8d, 0x87,
	0xa1, 0x9c, 0x8d, 0xd2, 0xa9, 0x79, 0x1e, 0x12, 0x9d, 0xe4, 0x41, 0x34, 0xe2, 0x22, 0x7f, 0x54,
	0x1a, 0x8e, 0x6e, 0xfd, 0x43, 0xc7, 0xab, 0xf6, 0xcf, 0xf9, 0xe2, 0x6f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x75, 0x08, 0x3d, 0xdd, 0x5f, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ReplicatorClient is the client API for Replicator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ReplicatorClient interface {
	// Returns available token offers
	GetTokenOffers(ctx context.Context, in *TokenOffersFilter, opts ...grpc.CallOption) (*TokenOffers, error)
	// Verifies a signature of an issuer for this token purchase. This
	// method should be called before channel initialization
	VerifyTokenPurchase(ctx context.Context, in *TokenPurchase, opts ...grpc.CallOption) (*CommonResult, error)
	// Registers token purchase to be tracked on the blockchain
	// right after some necessary token purchase checks
	RegisterTokenPurchase(ctx context.Context, in *TokenPurchase, opts ...grpc.CallOption) (*CommonResult, error)
	// Returns current token balances
	GetTokenBalances(ctx context.Context, in *TokenBalancesFilter, opts ...grpc.CallOption) (*TokenBalances, error)
}

type replicatorClient struct {
	cc *grpc.ClientConn
}

func NewReplicatorClient(cc *grpc.ClientConn) ReplicatorClient {
	return &replicatorClient{cc}
}

func (c *replicatorClient) GetTokenOffers(ctx context.Context, in *TokenOffersFilter, opts ...grpc.CallOption) (*TokenOffers, error) {
	out := new(TokenOffers)
	err := c.cc.Invoke(ctx, "/lnrpc.Replicator/GetTokenOffers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicatorClient) VerifyTokenPurchase(ctx context.Context, in *TokenPurchase, opts ...grpc.CallOption) (*CommonResult, error) {
	out := new(CommonResult)
	err := c.cc.Invoke(ctx, "/lnrpc.Replicator/VerifyTokenPurchase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicatorClient) RegisterTokenPurchase(ctx context.Context, in *TokenPurchase, opts ...grpc.CallOption) (*CommonResult, error) {
	out := new(CommonResult)
	err := c.cc.Invoke(ctx, "/lnrpc.Replicator/RegisterTokenPurchase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicatorClient) GetTokenBalances(ctx context.Context, in *TokenBalancesFilter, opts ...grpc.CallOption) (*TokenBalances, error) {
	out := new(TokenBalances)
	err := c.cc.Invoke(ctx, "/lnrpc.Replicator/GetTokenBalances", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReplicatorServer is the server API for Replicator service.
type ReplicatorServer interface {
	// Returns available token offers
	GetTokenOffers(context.Context, *TokenOffersFilter) (*TokenOffers, error)
	// Verifies a signature of an issuer for this token purchase. This
	// method should be called before channel initialization
	VerifyTokenPurchase(context.Context, *TokenPurchase) (*CommonResult, error)
	// Registers token purchase to be tracked on the blockchain
	// right after some necessary token purchase checks
	RegisterTokenPurchase(context.Context, *TokenPurchase) (*CommonResult, error)
	// Returns current token balances
	GetTokenBalances(context.Context, *TokenBalancesFilter) (*TokenBalances, error)
}

// UnimplementedReplicatorServer can be embedded to have forward compatible implementations.
type UnimplementedReplicatorServer struct {
}

func (*UnimplementedReplicatorServer) GetTokenOffers(ctx context.Context, req *TokenOffersFilter) (*TokenOffers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenOffers not implemented")
}
func (*UnimplementedReplicatorServer) VerifyTokenPurchase(ctx context.Context, req *TokenPurchase) (*CommonResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyTokenPurchase not implemented")
}
func (*UnimplementedReplicatorServer) RegisterTokenPurchase(ctx context.Context, req *TokenPurchase) (*CommonResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterTokenPurchase not implemented")
}
func (*UnimplementedReplicatorServer) GetTokenBalances(ctx context.Context, req *TokenBalancesFilter) (*TokenBalances, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenBalances not implemented")
}

func RegisterReplicatorServer(s *grpc.Server, srv ReplicatorServer) {
	s.RegisterService(&_Replicator_serviceDesc, srv)
}

func _Replicator_GetTokenOffers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenOffersFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicatorServer).GetTokenOffers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Replicator/GetTokenOffers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicatorServer).GetTokenOffers(ctx, req.(*TokenOffersFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _Replicator_VerifyTokenPurchase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenPurchase)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicatorServer).VerifyTokenPurchase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Replicator/VerifyTokenPurchase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicatorServer).VerifyTokenPurchase(ctx, req.(*TokenPurchase))
	}
	return interceptor(ctx, in, info, handler)
}

func _Replicator_RegisterTokenPurchase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenPurchase)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicatorServer).RegisterTokenPurchase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Replicator/RegisterTokenPurchase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicatorServer).RegisterTokenPurchase(ctx, req.(*TokenPurchase))
	}
	return interceptor(ctx, in, info, handler)
}

func _Replicator_GetTokenBalances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenBalancesFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicatorServer).GetTokenBalances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Replicator/GetTokenBalances",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicatorServer).GetTokenBalances(ctx, req.(*TokenBalancesFilter))
	}
	return interceptor(ctx, in, info, handler)
}

var _Replicator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lnrpc.Replicator",
	HandlerType: (*ReplicatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTokenOffers",
			Handler:    _Replicator_GetTokenOffers_Handler,
		},
		{
			MethodName: "VerifyTokenPurchase",
			Handler:    _Replicator_VerifyTokenPurchase_Handler,
		},
		{
			MethodName: "RegisterTokenPurchase",
			Handler:    _Replicator_RegisterTokenPurchase_Handler,
		},
		{
			MethodName: "GetTokenBalances",
			Handler:    _Replicator_GetTokenBalances_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tokens/replicator/replicator.proto",
}
